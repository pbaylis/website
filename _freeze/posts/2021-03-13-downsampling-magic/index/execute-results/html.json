{
  "hash": "7eb86243bd1babaf96c45457689ae9c8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"The magic of downsampling\"\ndescription: \"Efficiently plotting very high-resolution raster data with ggplot2 using terra and downsampling techniques\"\nauthor: \"Patrick Baylis\"\ndate: 2021-03-13\nformat: \n  html:\n    page-layout: full\ncategories:\n  - raster\n  - maps\n  - R\n---\n\n::: {.callout-note}\n# Updates\n\n- Updated 2025-11-24 to use rasters that can be downloaded.\n:::\n\nIt's time for another mapping post! For a recent project, I wanted to plot some **very** highly resolved raster data with ``ggplot2``, but I ran into a hiccup. In case it's useful to someone else, here's what I learned.\n\nFirst, some setup:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(terra, tidyverse, sf, cowplot, rnaturalearth) # World shapefile\n\nknitr::opts_knit$set(message = F, warning = F, cache = T)\n\ntheme_set(theme_map()) # We're only going to be making maps, so just set the theme here.\n```\n:::\n\n\nNote that I load the new-ish [`terra`](https://rspatial.org/terra/pkg/index.html) rather than the usual, and now venerable, [`raster`](https://www.rdocumentation.org/packages/raster/) package. `terra` is the successor to `raster`, and in general it's much, much faster (because its written in C++). But everything I do below with `terra` could be done with `raster` instead.\n\nFor this exercise, we'll use the Natural Earth II (downloaded [here](https://www.naturalearthdata.com/downloads/10m-raster-data/10m-natural-earth-2/) and described in detail [here](http://www.shadedrelief.com/natural2/index.html)). It's a raster of what the earth might look like without humans. Hopefully not a projection. It's a 1:10m, world-wide raster, which means that each cell represents a very small chunk of the earth. So there are a **LOT** of chunks. More than 230 million to be exact.\n\nFirst, we'll load the raster and try to plot it. Will it work?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntr <- terra::rast(\"~/Downloads/NE2_HR_LC_SR_W_DR/NE2_HR_LC_SR_W_DR.tif\")[[1]]\nplot(tr)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/load-raster-1.png){width=672}\n:::\n:::\n\n\nWow, looks great! And it plotted in less than a second. How did `plot` (actually `terra::plot`) display hundreds of millions of pieces of information so quickly? It didn't, it turns out. Through the magic of **downsampling** (or aggregating, or downscaling, or ...), the function cleverly takes averages over larger areas, effectively creating a coarser raster with fewer cells. This makes no difference visually, since neither the human eye nor your monitor is capable of detecting or displaying the differences between the very tiny cells represented by the true data at this scale. So what is downsampling actually doing? Borrowing a visual from the ArcGIS [documentation](https://desktop.arcgis.com/en/arcmap/latest/tools/spatial-analyst-toolbox/aggregate.htm), downsampling is converting a high-resolution raster into a lower-resolutation raster.\n\n![Downsampling or aggregating (Source: ArcMap Documentation)](downsampling-arc.png)\n\nYou can think of the downsampling operation as converting a high-resolution raster like the one on the left to a lower-resolution raster like the one on the right by taking some summary (above, a mean) over sets of cells. By summarizing many cells into fewer cells, it leaves `plot` with a lot less work to do. \n\nBut, let's say you've taken great pains to produce all of your other figures using the consistent visual styling offered by [``ggplot2``](https://ggplot2.tidyverse.org/). You might feel inexplicably compelled to try to want to plot this map using ``ggplot`` as well. Fortunately, this is doable, at least in principle: you can simply convert, or \"fortify\", the raster to `data.frame` that `ggplot` can use. Here's how we would do that:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# tr_df <- as.data.frame(tr, xy = T)\n# nrow(tr_df) \n```\n:::\n\n\nWhy is that commented out? Because it takes a long time (and screws up my `knitr` process). What happened? Remember those 230m+ cells? If we fortify that raster, it becomes a massive, 230 *million* row `data.frame`. This is a big problem, because ``ggplot`` is not going to be able to plot all of these in a reasonable amount of time (take my word for it...). \n\nSo what can we do? One option is to take a page out of the `terra` playbook and downsample ourselves. We'll use the function `terra::aggregate` with a factor of 10 both horizontally and vertically, which should reduce the total cells by a factor of 100.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntr_a <- terra::aggregate(tr, fact = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n```\n\n\n:::\n\n```{.r .cell-code}\ntr_a_df <- as.data.frame(tr_a, xy = T)\nnrow(tr_a_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2332800\n```\n\n\n:::\n:::\n\n\nNow we have 2 million rather than 233 million rows. This is a lot, but actually well within the capabilities of `ggplot2::geom_raster`. Let's take a look:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(tr_a_df, aes(x = x, y = y, fill = NE2_HR_LC_SR_W_DR_1)) + \n  geom_raster() + \n  scale_fill_viridis_c(direction = -1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/rast-ggplot-1.png){width=672}\n:::\n:::\n\n\nTo see how this can be useful, we'll download a shapefile of the countries of the world.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld <- rnaturalearth::ne_countries(scale = \"small\", returnclass = \"sf\")\nggplot(world) + geom_sf()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/world-shp-1.png){width=672}\n:::\n:::\n\n\nNext, we'll reproject the raster to the same projection as as the world shapefile and aggregate and fortify again.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntr_p <- terra::project(tr, st_crs(world)$proj4string)\ntr_p_a <- terra::aggregate(tr_p, fact = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n```\n\n\n:::\n\n```{.r .cell-code}\ntr_p_a_df <- as.data.frame(tr_p_a, xy = T)\n```\n:::\n\n\nAnd plot, this time with country boundaries.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(world) + \n  geom_raster(data = tr_p_a_df, mapping = aes(x = x, y = y, fill = NE2_HR_LC_SR_W_DR_1)) + \n  geom_sf(colour = alpha(\"white\", 0.5), fill = NA) + \n  scale_fill_viridis_c(direction = -1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-boundaries-1.png){width=672}\n:::\n:::\n\n\nConverting the raster into a `ggplot`-compatible object opens up a whole world of visualization, but we'll stop here for now. I hope this has given you a sense for how to smoothly integrate large spatial rasters with your usual `ggplot2` and `sf` spatial work. Happy mapping! ",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}