{
  "hash": "e8574417a8953daec44008d2147060e3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"How to plot a specification curve\"\ndescription: \"A simple tidyverse approach to creating specification curves for sensitivity analysis\"\nauthor: \"Patrick Baylis\"\ndate: 2020-02-28\nformat: \n  html:\n    page-layout: full\ncategories:\n  - R\n  - visualization\n  - econometrics\n---\n\nLike many researchers, I often want to plot a range of coefficient estimates to figure out if the results I'm finding are robust to other sensible specification and functional form choices. This kind of estimate is called a specification curve ([Simonsohn, Simmons, and Nelson 2015](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2694998)), and I [am](https://twitter.com/ArielOrtizBobea/status/1233224906709618689) [far](https://twitter.com/hhsievertsen/status/1188780383736909825) [from](https://twitter.com/deaneckles/status/1171175422219866112) [the](https://twitter.com/icymi_r/status/1208660197763362816) [first](https://twitter.com/JoachimGassen/status/1122410367915823104) [to](https://twitter.com/Bachl/status/1200325153902780417) [do](https://twitter.com/JoachimGassen/status/1203326365715619840) [it](https://twitter.com/thaddunning/status/1146505592682504194). In fact, there are even a couple packages available: [Joachim Gassen's `rdfanalysis`](https://github.com/joachim-gassen/rdfanalysis) and [Philipp Masur's `specr`](https://github.com/masurp/specr) (I haven't used either, yet).\n\nI wanted to roll my own, though. Since my code is fairly simple (less than 60 lines including comments and generous spacing) and uses the [`tidyverse`](https://www.tidyverse.org/), it may be helpful to other people too. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse, cowplot, fastDummies)\ntheme_set(theme_cowplot())\nset.seed(42)\n```\n:::\n\n\nFirst, we create some fake estimates. This includes the point estimates, standard errors, and any variables that describe the specifications we \"estimated\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfe <- c(\"Unit\", \"Time\", \"Unit + Time\")\ncontrols <- c(\"Basic\", \"Some\", \"Full\")\n\nestimates <- as_tibble(expand.grid(`Fixed Effects` = fe, `Controls` = controls))\nestimates <- estimates %>% mutate(est = rnorm(n()), se = runif(n(), 0, 0.1))\nestimates <- estimates %>% mutate(ci_l = est - 1.96 * se, ci_h = est + 1.96 * se)\n```\n:::\n\n\nNext, we construct a typical coefficient plot that shows how the estimates and confidence intervals change across different categories.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspec_cols <- c(\"Fixed Effects\", \"Controls\") # Could be set by user or figured out\n\nestimates <- estimates %>%\n  arrange(est) %>%\n  mutate(h_order = 1:n()) # Sort on point estimates for horizontal ordering\n\ncoef_plot <- ggplot(estimates, aes(x = h_order, y = est)) +\n  geom_linerange(aes(ymin = ci_l, ymax = ci_h), linewidth = 1, alpha = 0.5) +\n  geom_point(fill = \"white\", shape = 21) +\n  labs(y = \"Coefficient\") +\n  theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.line.x = element_blank(), axis.text.x = element_blank())\n```\n:::\n\n\nThen we visualize the specifications themselves as a series of dot plots below the coefficient plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_spec_plot <- function(category) {\n  # Creates a dot plot for one specification category\n  specs <- dummy_cols(estimates, select_columns = category, remove_selected_columns = T) %>%\n    select(h_order, starts_with(category)) %>%\n    pivot_longer(starts_with(category), names_prefix = paste0(category, \"_\")) %>%\n    mutate(name = factor(name, levels = rev(unique(name))))\n\n  spec_plot <- ggplot(specs, aes(x = h_order, y = name, alpha = value)) +\n    geom_point() +\n    scale_alpha_continuous(guide = \"none\") +\n    theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.line.x = element_blank(), axis.text.x = element_blank()) +\n    theme(axis.text.y = element_text(size = 6), axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.line.y = element_blank())\n  spec_plot\n}\nspec_plots <- lapply(spec_cols, make_spec_plot)\n```\n:::\n\n\nFinally, we combine them for the final result:\n\n::: {.cell}\n\n```{.r .cell-code}\ncombined_plot <- plot_grid(\n  plotlist = c(list(coef_plot), spec_plots),\n  labels = c(\"\", spec_cols), label_size = 8, label_fontface = \"italic\", vjust = 0.5, hjust = -0.1,\n  rel_heights = c(1, 0.2, 0.2), ncol = 1, align = \"v\"\n)\n\ncombined_plot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/combine-plots-1.png){width=672}\n:::\n:::\n\n\nThis approach is flexible and can be easily adapted to include more specification categories, different aesthetics, or other customizations. Happy plotting!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}